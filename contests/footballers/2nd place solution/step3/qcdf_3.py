# -*- coding: utf-8 -*-
"""QCDF-3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dHOmJvkj1CFYhSPWdJh8FU2_KAQf0hRJ
"""

from keras.models import load_model

model = load_model("drive/MyDrive/QCDF_model.h5")

!unzip "drive/MyDrive/Captain Tsubasa.zip"

import pandas as pd

train = pd.read_csv('train.csv')

matches = []
for i in range(240):
  matches.append([0] * 4)

for i, row in train.iterrows():
  matches[int(row['matchId'].split('_')[1]) - 1][list(set(train['playType'].tolist())).index(row['playType'])] += 1

df = pd.DataFrame(matches, columns=list(set(train['playType'].tolist())))
df.describe()

sum_w = 0
for i in range(len(list(set(train['playType'].tolist())))):
  sum_w += df[list(set(train['playType'].tolist()))[i]].mean()

weights = []
for i in range(len(list(set(train['playType'].tolist())))):
  weights.append(df[list(set(train['playType'].tolist()))[i]].mean() / sum_w)

X = []
y_true = []
for i, row in train.iterrows():
  X.append([row['minute'], row['second'], abs(row['x']), abs(row['y']),
            list(set(train['playType'].tolist())).index(row['playType']),
            list(set(train['bodyPart'].tolist())).index(row['bodyPart']),
            row['interveningOpponents'],
            row['interveningTeammates'],
            list(set(train['interferenceOnShooter'].tolist())).index(row['interferenceOnShooter'])])
  if 'گُل' in row['outcome']:
    y_true.append(1)
  else:
    y_true.append(0)

y_pred = model.predict(X)

count_matches = []
for i in range(160):
  count_matches.append([0] * 240)

for i, row in train.iterrows():
  count_matches[int(row['playerId'].split('_')[1]) - 1][int(row['matchId'].split('_')[1]) - 1] = 1

final = [0] * 160
data = []

for i in range(len(y_pred)):
  if y_pred[i] >= 0.5 and y_true[i] == 1:
    final[int(train['playerId'].tolist()[i].split('_')[1]) - 1] += weights[list(set(train['playType'].tolist())).index(train['playType'].tolist()[i])]
    data.append(1)
  elif y_pred[i] >= 0.5 and y_true[i] == 0:
    final[int(train['playerId'].tolist()[i].split('_')[1]) - 1] -= 2 * weights[list(set(train['playType'].tolist())).index(train['playType'].tolist()[i])]
    data.append(0)
  elif y_pred[i] < 0.5 and y_true[i] == 1:
    final[int(train['playerId'].tolist()[i].split('_')[1]) - 1] += 2 * weights[list(set(train['playType'].tolist())).index(train['playType'].tolist()[i])]
    data.append(0)
  if y_pred[i] < 0.5 and y_true[i] == 0:
    final[int(train['playerId'].tolist()[i].split('_')[1]) - 1] -= weights[list(set(train['playType'].tolist())).index(train['playType'].tolist()[i])]
    data.append(1)

for i in range(len(final)):
  final[i] = final[i] / sum(count_matches[i])

sorted(range(len(final)), key=lambda i: final[i])[-5:]

import matplotlib.pyplot as plt

plt.hist(data)
plt.show()